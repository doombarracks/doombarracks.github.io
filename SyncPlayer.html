<!DOCTYPE html>
<html lang="zh-cmn-Hant">
<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158627278-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'UA-158627278-1');
	</script>

	<title>YouTube Sync</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
	<link rel="stylesheet" href="Styles/DBStyles.css">
	<style>
		body {
			min-width: 320px;
		}

		#yt_sync_container {
			position: relative;
			margin: auto;
			padding: 0;
			width: 100vw;
			height: 100vh;
			background-color: #222;
			font-size: 0;
			overflow: hidden;
		}

		ul.msg-box {
			position: absolute;
			left: 8px;
			top: 8px;
			margin: 0;
			padding: 0;
			z-index: 2;
			font-family: "DooM";
			font-size: 14px;
			list-style-type: none;
		}

		/* Message line. */
		ul.msg-box > li {
			margin: 0;
			padding: 0;
		}

		ul.msg-box > li > span {
			margin: 0;
			padding: 4px 12px;
			text-transform: uppercase;
			text-shadow: -1px -1px 0.1em black, -1px 1px 0.1em black, 1px -1px 0.1em black, 1px 1px 0.1em black;
			overflow: hidden;
			border-radius: 4px;
			background-color: rgba(0, 0, 0, 0.2);
		}

		ul.msg-box > li.say {
			line-height: 26px;
		}

		/* Player name. */
		ul.msg-box > li.say > span > span:nth-child(1) {
			color: cyan;
		}
		ul.msg-box > li.say > span > span:nth-child(1):after {
			content: ": ";
		}

		/* Chat content. */
		ul.msg-box > li.say > span > span:nth-child(2) {
			color: #ddd;
		}

		ul.msg-box > li.set-player {
			line-height: 26px;
		}
		
		/* Set player message. */
		ul.msg-box > li.set-player > span {
			color: yellow;
		}

		ul.msg-box > li.set-player > span > span.name {
			color: cyan;
		}

		/* Map. */
		ul.msg-box > li.map {
			line-height: 52px;
		}
		ul.msg-box > li.map > span {
			padding: 8px 20px;
			color: #fff;
			font-size: 26px;
			border-radius: 12px;
		}

		/* Player name. */
		ul.msg-box > li.kick > span > span:nth-child(1) {
			color: magenta;
		}
		ul.msg-box > li.kick > span > span:nth-child(1):after {
			content: " ";
		}

		/* Kick message. */
		ul.msg-box > li.kick > span > span:nth-child(2) {
			color: yellow;
		}

		/* Sychronization failed message. */
		ul.msg-box > li.sync-fail > span {
			color: red;
		}

		.yt_sync_box {
			position: absolute;
			margin: 0;
			padding: 0;
			z-index: 1;
		}

		.yt_sync_box > * {
			pointer-events: none;
			user-select: none;
			margin: 0;
			padding: 0;
		}

		.box_cover {
			position: absolute;
			width: 100%;
			height: 100%;
			opacity: 0;
		}

		.box_cover.drag_src {
			opacity: 0.25;
			background-color: white;
		}

		.box_cover.drag_dst {
			opacity: 0.25;
			background-color: red;
		}

		/* Video box. */
		.yt_sync_box > iframe {
			box-sizing: border-box;
			width: 100%;
			height: 100%;
			transition: opacity 1s;
			opacity: 0.25;
		}

		.yt_sync_box.desync > iframe {
			border-width: 4px;
			border-color: red;
			animation: desync-animation 5s infinite;
		}

		@keyframes desync-animation {
			0%   { border-color:red; }
			50%  { border-color:yellow;}
			100% { border-color:red; }
		}

		.yt_sync_box.connected > iframe{
			opacity: 1;
		}

		/* Player name. */
		.yt_sync_box > div.name {
			position: absolute;
			top: 8px;
			width: 100%;
			font-family: "DooM";
			font-size: 16px;
			line-height: 16px;
			text-transform: uppercase;
			color: #444;
			text-shadow: -1px -1px 0.1em black, -1px 1px 0.1em black, 1px -1px 0.1em black, 1px 1px 0.1em black;
			text-align: center;
			transition: color 1s;
		}

		.yt_sync_box.connected > div.name {
			color: #ddd;
			transition: color 1s;
		}

		.yt_sync_box > div.debugger {
			pointer-events: all;
			position: absolute;
			left: 50%;
			top: 10%;
			transform: translateX(-50%);
			z-index: 10;
		}
		.yt_sync_box > div.debugger > * {
			font-size: 12px;
			padding: 2px;
		}
		.yt_sync_box > div.debugger > .btn {
			cursor: pointer;
			border: 1px solid white;
			border-radius: 4px;
			background-color: rgba(0, 0, 0, 0.25);
			white-space: nowrap;
		}

		#debugger-global {
			pointer-events: all;
			position: fixed;
			font-size: 12px;
			color: cyan;
			right: 0.25em;
			top: 0.25em;
			z-index: 10;
		}
		#debugger-global > .btn {
			cursor: pointer;
			margin: 1px;
			padding: 1px;
			border: 1px solid cyan;
			border-radius: 4px;
			background-color: rgba(0, 0, 0, 0.25);
			white-space: nowrap;
		}

		/* Controls container. */
		#yt_sync_container .control {
			position: absolute;
			bottom: 0;
			width: 100%;
			opacity: 0;
			font-size: 16px; /* Base font size for all children. */
			transition: opacity 0.3s;
			z-index: 3;
		}

		#yt_sync_container .control:hover,
		#yt_sync_container .control.show {
			opacity: 1;
		}

		#yt_sync_container .control > .progress {
			position: relative;
			margin: 0;
			padding: 0;
			width: 100%;
			height: 3.5em;
			overflow: hidden;
		}

		#yt_sync_container .control > .progress > .back {
			position: absolute;
			margin: 0;
			padding: 0;
			width: 100%;
			height: 0.625em;
			bottom: 0;
			overflow: hidden;
		}

		#yt_sync_container .control > .progress > .bar {
			position: absolute;
			cursor: pointer;
			width: 100%;
			height: 0.3em;
			left: 0;
			bottom: 0.45em;
			background-color: white;
		}
		
		#yt_sync_container .control > .progress > .bar > .elapsed {
			position: absolute;
			left: 0;
			top: 0;
			height: 100%;
			width: 0%; /* Determined by script. */
			background-color: red;
		}
		
		#yt_sync_container .control > .progress > .bar > .seek-before {
			position: absolute;
			left: 0;
			top: 0;
			height: 100%;
			width: 0%; /* Determined by script. */
			background-color: yellow;
		}
		
		#yt_sync_container .control > .progress > .bar > .seek-after {
			position: absolute;
			left: 0;
			top: 0;
			height: 100%;
			width: 0%; /* Determined by script. */
			background-color: cyan;
		}
		
		#yt_sync_container .control > .progress > .pointer {
			position: absolute;
			pointer-events: none;
			border-radius: 50%;
			height: 1.2em;
			width: 1.2em;
			left: 0%; /* Determined by script. */
			/*top: calc(50% - 0.6em);*/
			bottom: 0;
			background-color: red;
			transform: translateX(-50%);
		}

		.bar-time {
			position: absolute;
			pointer-events: none;
			background-color: black;
			padding: 0.5em;
			opacity: 0;
			height: 1.25em;
			line-height: 1.25em;
			text-align: center;
			width: auto;
			top: 0;
			left: 0%; /* Determined by script. */
			transform: translateX(-50%);
			transition: opacity 0.5s;
		}

		.bar-time.show {
			opacity: 0.8;
			transition: opacity 0.2s;
		}

		#yt_sync_container .control > .buttons {
			position: relative;
			margin: 0;
			padding: 0 0.75em 0.25em 0.75em;
			width: calc(100% - 1.5em);
			height: auto;
			overflow: hidden;
		}

		#yt_sync_container .control > .buttons .left {
			float: left;
		}

		#yt_sync_container .control > .buttons .right {
			float: right;
		}

		#yt_sync_container .control > .buttons .btn {
			position: relative;
			width: 3em;
			height: 2.4em;
			text-align: center;
			text-shadow: 2px 2px #000000;
		}

		#yt_sync_container .control > .buttons .btn i {
			position: absolute;
			cursor: pointer;
			left: 50%;
			top: 50%;
			font-size: 1.5em;
			transform: translate(-50%, -50%);
			transition: opacity 0.5s, font-size 0.5s;
		}

		.btn.music > i.mute,
		.btn.sound > i.mute {
			color: #444;
		}

		#time-display {
			padding: 0 1em 0 1em;
			font-size: 1.25em;
			font-family: "Tahoma";
			color: white;
			white-space: nowrap;
			pointer-events: none;
			user-select: none;
		}
	</style>
</head>
<body>
	<div id="sync_videos">
		<div id="yt_sync_container">
			<ul class="msg-box"></ul>
			<div class="control">
				<div class="progress">
					<div class="bar">
						<div class="seek-after"></div>
						<div class="elapsed"></div>
						<div class="seek-before"></div>
					</div>
					<div class="pointer"></div>
					<div class="bar-time"></div>
				</div>
				<div class="buttons">
					<div class="play btn left">
						<i class="fa fa-play"></i>
					</div>
					<div class="music btn left">
						<i class="fa fa-music"></i>
						<audio loop style="display:none"><source /></audio>
					</div>
					<div class="sound btn left">
						<i class="fa fa-volume-up"></i>
					</div>
					<div class="time btn left">
						<span id="time-display"></span>
					</div>
					<div class="full-screen btn right">
						<i class="fa fa-expand-arrows-alt"></i>
					</div>
					<div class="tile-layout btn right">
						<i class="fas fa-square"></i>
					</div>
					<div class="parent-child-layout btn right">
						<i class="fas fa-th-large"></i>
					</div>
				</div>
			</div>
		</div>
	</div>
	<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
	<script src="https://www.youtube.com/iframe_api"></script>
	<script src="Scripts/Data/GameInfoTable.js"></script>
	<script>
		$(document).ready(function() {
			const urlParams = new URLSearchParams(window.location.search);
			const videojs = urlParams.get("videojs");
			const title = urlParams.get("title");

			if (title) document.title = title;

			Initializer.LoadDemoScript(videojs);
		});

		function onYouTubeIframeAPIReady() {
			Initializer.APIReady();
		}

		// Class to make sure demo will be run after YouTube API is loaded.
		var Initializer = new function() {
			var _ytApiReady = false;
			var _pendingDemoInfo;

			this.APIReady = function() {
				_ytApiReady = true;
				if (_pendingDemoInfo) {
					Initializer.PrepareDemo(_pendingDemoInfo);
					_pendingDemoInfo = undefined;
				}
			}

			this.LoadDemoScript = function(fileName) {
				let script = document.createElement("script");
				script.onload = function () {
					Initializer.PrepareDemo(singleDemoInfo);
				};
				$("#SingleDemoScript").remove();
				script.src = "GameInfo/DemoInfo/" + fileName + ".js";
				script.id = "SingleDemoScript";
				document.head.appendChild(script);
			}

			this.PrepareDemo = function(demoInfo) {
				if (!_ytApiReady) {
					_pendingDemoInfo = demoInfo;
					return;
				}
				DemoPlayer.Initialize(demoInfo, "sync_videos");
			}
		}

		var DemoPlayer = new function() {
			var _userContainerJq;
			var _containerJq;
			var _demo;
			var _syncVideoList;

			var _outOfSync = false;

			var _scanLoopIntervalID = 0;

			this.Initialize = function(demo, containerID) {
				this.Close();

				// Make our own container so we have full control over it.
				_containerJq = $("#yt_sync_container");
				if (_containerJq.length == 0) {
					_containerJq = $("<div id='yt_sync_container'></div>");
				}

				// Use container to enclose everything.
				_userContainerJq = $("#" + containerID);
				_userContainerJq.append(_containerJq);

				VideoSync.Start(demo);
				UI.Start();

				_scanLoopIntervalID = setInterval(ScanLoop, 100);
			}

			this.Close = function() {
				Activity.Close();
				UI.Close();
				VideoSync.Close();
			}

			function ScanLoop() {
				CheckDesync();
				VideoSync.ScanLoop();
				Activity.ScanLoop();
				Sound.ScanLoop();
				Music.ScanLoop();
			}

			function CheckDesync() {
				if (!VideoSync.IsPlaying()) return;

				// Uses time from the first video as reference.
				let vt = VideoSync.GetSyncVideosCurrentTime();

				let oos = false;
				for (var i in _syncVideoList) {
					let sv = _syncVideoList[i];
					let t = typeof(sv) !== "undefined" && typeof(sv.Player) !== "undefined" && typeof(sv.Player.getCurrentTime) === "function"
						? sv.Player.getCurrentTime() - sv.VideoInfo.ZeroTime - _demo.ActivityTimeOffset
						: vt;
					if (Math.abs(t - vt) >= 1.0) {
						$("#" + sv.BoxID).addClass("desync");
						oos = true;
					}
					else {
						$("#" + sv.BoxID).removeClass("desync");
					}
				}

				if (oos && !_outOfSync) {
					console.log("Video gets out of sync.");
					UI.AddLine("sync-fail", "<span>Video gets out of sync.</span>", 1000, 10000);
				}
				_outOfSync = oos;
			}

			var DemoInfoFile = new function() {
				function LoadFile(path) {
					$.getScript(path, function(data, textStatus, jqxhr) {
						;
					});
				}
				this.LoadFile = LoadFile;
			}

			var VideoSync = new function() {
				var _initialized = false;

				this.Start = function(demo) {
					_demo = demo;

					if (typeof(_demo.ActivityTimeOffset) !== "number") {
						_demo.ActivityTimeOffset = 0.0;
					}
					if (typeof(_demo.ActivityTimeScale) !== "number") {
						_demo.ActivityTimeScale = 1.0;
					}

					_tpn2svl = {};
					_syncVideoList = [];
					let videos = demo.Videos;
					for (let i in videos) {
						// Make a deep copy of source info.
						let info = videos[i];

						// Create UI objects.
						let iFrameID = "yt_sync_" + info.VideoID;
						let boxID = "yt_box_" + info.VideoID
						_containerJq.append(
							"<div id='" + boxID + "' class='yt_sync_box'>" +
								"<div class='box_cover'></div>" +
								"<div id='" + iFrameID + "'></div>" +
								"<div class='name'>" + info.PlayerName + "</div>" +
							"</div>");

						let syncVideo = {
							VideoInfo: info,
							IFrameID: iFrameID,
							BoxID: boxID,
							Player: undefined,
							YouTubeLoadReady: false,
						};

						let player = new YT.Player(iFrameID, {
							videoId: info.VideoID,
							/* // Width and height will be automatically fit to css-defined size.
							width: 400,
							height: 300,
							*/
							playerVars: {
								autoplay: 0, // This parameter specifies whether the initial video will automatically start to play when the player loads. Supported values are 0 or 1. The default value is 0.
								cc_load_policy: 0, // Setting the parameter's value to 1 causes closed captions to be shown by default, even if the user has turned captions off. The default behavior is based on user preference.
								controls: 0, // This parameter indicates whether the video player controls are displayed
								disablekb: 1, // Setting the parameter's value to 1 causes the player to not respond to keyboard controls. The default value is 0, which means that keyboard controls are enabled.
								enablejsapi: 0, // 	Setting the parameter's value to 1 enables the player to be controlled via IFrame or JavaScript Player API calls. The default value is 0, which means that the player cannot be controlled using those APIs.
								fs: 0, // Setting this parameter to 0 prevents the fullscreen button from displaying in the player. The default value is 1, which causes the fullscreen button to display.
								iv_load_policy: 1, // Setting the parameter's value to 1 causes video annotations to be shown by default, whereas setting to 3 causes video annotations to not be shown by default. The default value is 1.
								loop: 0, // In the case of a single video player, a setting of 1 causes the player to play the initial video again and again. In the case of a playlist player (or custom player), the player plays the entire playlist and then starts again at the first video.
								modestbranding: 0, // This parameter lets you use a YouTube player that does not show a YouTube logo. Set the parameter value to 1 to prevent the YouTube logo from displaying in the control bar. Note that a small YouTube text label will still display in the upper-right corner of a paused video when the user's mouse pointer hovers over the player.
								rel: 0, // This parameter indicates whether the player should show related videos when playback of the initial video ends. Supported values are 0 and 1. The default value is 1.
								showinfo: 0, // Setting the parameter's value to 0 causes the player to not display information like the video title and uploader before the video starts playing.
								start: typeof(info.StartTime) === "number" ? info.StartTime : 0,
							},
							events: {
								onReady: function(event) { YTE_OnReady(syncVideo, event); },
								onStateChange: function(event) { YTE_OnStateChange(syncVideo, event); },
								onPlaybackQualityChange: function(event) { YTE_OnPlaybackQualityChange(syncVideo, event); },
								onPlaybackRateChange: function(event) { YTE_OnPlaybackRateChange(syncVideo, event); },
								onError: function(event) { YTE_OnError(syncVideo, event); }
							}
						});

						syncVideo.Player = player;
						syncVideo.Seek = { Time: 0.0, Seeking: false, Mute: false, Debug: false };
						_syncVideoList.push(syncVideo);

						let tpn = DemoHelper.GetTruePlayerName(info.PlayerName);
						_tpn2svl[tpn] = syncVideo;

						//AttachDebugger(tpn);
					}

					_initialized = true;
				}

				this.Close = function() {
					if (Array.isArray(_syncVideoList)) {
						for (let i in _syncVideoList) {
							_syncVideoList[i].Player.destroy();
						}
					}
					_syncVideoList = undefined;
					_demo = undefined;
				}

				this.GetPrimarySyncVideo = function() {
					for (var i in _syncVideoList)
					{
						let boxDOM = $("#" + _syncVideoList[i].BoxID)[0];
						if (UI.GetBoxIndex(boxDOM) === 0) {
							return _syncVideoList[i];
						}
					}
					return undefined;
				}

				var _tpn2svl; // True player name to sync video list.

				this.GetSyncVideo = function(truePlayerName) {
					return _tpn2svl[truePlayerName];
				}

				var _syncVideosDuration;
				this.GetSyncVideosDuration = function() {
					return _syncVideosDuration;
				}

				this.GetSyncVideosCurrentTime = function() {
					let sv = this.GetPrimarySyncVideo();

					return typeof(sv) !== "undefined" && typeof(sv.Player) !== "undefined" && typeof(sv.Player.getCurrentTime) === "function"
						? sv.Player.getCurrentTime() - sv.VideoInfo.ZeroTime - _demo.ActivityTimeOffset
						: 0.0;
				}

				this.IsPlaying = function() {
					return VideoSync.GlobalPlayState === YT.PlayerState.PLAYING;
				}

				function UpdateGlobalPlayState() {
					let playing = true,
						paused = false,
						ended = false,
						buffering = false;
					for (let i in _syncVideoList) {
						let ps = _syncVideoList[i].Player.getPlayerState();
						if (ps != YT.PlayerState.PLAYING) playing = false;
						if (ps == YT.PlayerState.PAUSED) paused = true;
						if (ps == YT.PlayerState.ENDED) ended = true;
						if (ps == YT.PlayerState.BUFFERING) buffering = true;

						/*
						switch (event.data) {
							case YT.PlayerState.UNSTARTED:
							case YT.PlayerState.ENDED:
							case YT.PlayerState.PLAYING:
							case YT.PlayerState.PAUSED:
							case YT.PlayerState.BUFFERING:
							case YT.PlayerState.CUED:
						}
						*/
					}

					let state = YT.PlayerState.UNSTARTED;
					if (playing) state = YT.PlayerState.PLAYING;
					if (paused) state = YT.PlayerState.PAUSED;
					if (buffering) state = YT.PlayerState.BUFFERING;
					if (ended) state = YT.PlayerState.ENDED;
					
					VideoSync.GlobalPlayState = state;
				}
				this.GlobalPlayState = -1; // YT.PlayerState.UNSTARTED

				this.ScanLoop = function() {
					if (!_initialized) return;
					CheckVideoSynchronization();
				}

				var _syncTime = undefined;
				var _syncMute = undefined;

				var _resyncCounter = 0;

				function CheckVideoSynchronization() {
					if (!isFinite(_syncTime) || _syncTime < 0) return;

					let synced = true;
					let resync = false;

					// Mute sound.
					Sound.ForceMute(true);

					for (let k in _syncVideoList) {
						let sv = _syncVideoList[k];
						let p = sv.Player;

						if (typeof(p.getCurrentTime) !== "function"
							|| typeof(p.getPlayerState) !== "function") {
							synced = false; // Flag sync fail as an error.
							continue;
						}

						// Actual video time.
						let vt = _syncTime + sv.VideoInfo.ZeroTime + _demo.ActivityTimeOffset;

						// Check whether this video is at correct time.
						let dt = Math.abs(p.getCurrentTime() - vt);
						if (dt >= 0.1) {
							// Too far, we need to seek video.

							let state = p.getPlayerState();
							let pause = dt < 1;
							switch (state) {
								case YT.PlayerState.PLAYING:
									p.seekTo(vt);
									resync = true;
									break;
								case YT.PlayerState.BUFFERING:
									pause = true;
									break;
								case YT.PlayerState.UNSTARTED:
								case YT.PlayerState.CUED:
								case YT.PlayerState.PAUSED:
								case YT.PlayerState.ENDED:
									p.seekTo(vt);
									resync = true;
									break;
							}

							if (pause) p.pauseVideo();
							else p.playVideo();

							synced = false; // Not synchronized in this iteration.
						}
						else {
							// Close enough, we should keep it paused.

							let state = p.getPlayerState();
							switch (state) {
								case YT.PlayerState.PLAYING:
									p.pauseVideo();
									p.seekTo(vt);
									break;
								case YT.PlayerState.PAUSED:
									break;
								case YT.PlayerState.BUFFERING:
									p.pauseVideo();
									break;
								case YT.PlayerState.ENDED:
									p.seekTo(vt);
								case YT.PlayerState.UNSTARTED:
								case YT.PlayerState.CUED:
									p.playVideo();
									break;
							}

							if (state !== YT.PlayerState.PAUSED) {
								synced = false;
							}
						}
					}
					
					if (resync) {
						_resyncCounter++;
					}
					else {
						_resyncCounter = 0;
					}

					if (!synced) {
						// Pause video if resync too many times.
						if (_resyncCounter >= 20) {
							_syncTime = undefined; // Cancel sync.
							for (let k in _syncVideoList) {
								_syncVideoList[k].Player.pauseVideo();
							}
						}

						return;
					}

					// All synchronized. We can continue playing.
					for (let k in _syncVideoList) {
						let p = _syncVideoList[k].Player;
						p.playVideo();
					}

					// Recover sound.
					Sound.ForceMute(false);

					// Reset value.
					_syncTime = undefined;
					UI.UpdateSeekBar(_syncTime);
				}

				function AttachDebugger(tpn) {
					let sv = _tpn2svl[tpn];

					function GetCurrentTime() {
						return typeof(sv) !== "undefined" && typeof(sv.Player) !== "undefined" && typeof(sv.Player.getCurrentTime) === "function"
							? sv.Player.getCurrentTime()
							: 0;
					}

					// Attach local/video-specific debugger.
					let dbg = $("<div class='debugger'>"
						+ "<span class='btn'>-0.01</span>"
						+ "<span class='btn'>-0.05</span>"
						+ "<span class='btn'>-0.1</span>"
						+ "<span class='time'>" + sv.VideoInfo.ZeroTime.toFixed(2) + "</span>"
						+ "<span class='btn'>+0.1</span>"
						+ "<span class='btn'>+0.05</span>"
						+ "<span class='btn'>+0.01</span>"
						+ "</div>");

					dbg.find(".btn").click(function() {
						let tMin = 0,
							tMax = VideoSync.GetSyncVideosDuration();

						let shift = parseFloat($(this).html());
						let zt = sv.VideoInfo.ZeroTime + shift;
						zt = zt < tMin ? tMin : (zt > tMax ? tMax : zt);
						sv.VideoInfo.ZeroTime = zt;

						dbg.find(".time").html(zt.toFixed(2));

						//VideoSync.SynchronizeTimeDelta(-Math.max(2 - shift, 2));
						let t = (Activity.GetClosestActivityTime("Say") - _demo.ActivityTimeOffset) / _demo.ActivityTimeScale - 2;
						VideoSync.SynchronizeTime(t);
					});

					$("#" + sv.BoxID).append(dbg);

					// Attach global debugger.
					let gDbgJq = $("#debugger-global");
					if (gDbgJq.length > 0) return;
					let gDbg = $("<div id='debugger-global'>"
						+ "<span class='btn'>-0.0005</span>"
						+ "<span class='btn'>-0.0001</span>"
						+ "<span class='btn'>-0.00005</span>"
						+ "<span class='btn'>-0.00001</span>"
						+ "<span class='time'>" + _demo.ActivityTimeScale.toFixed(5) + "</span>"
						+ "<span class='btn'>+0.00001</span>"
						+ "<span class='btn'>+0.00005</span>"
						+ "<span class='btn'>+0.0001</span>"
						+ "<span class='btn'>+0.0005</span>"
						+ "</div>");

					gDbg.find(".btn").click(function() {
						let shift = parseFloat($(this).html());
						let ats = _demo.ActivityTimeScale + shift;
						ats = Math.max(ats, 0);
						_demo.ActivityTimeScale = ats;

						gDbg.find(".time").html(ats.toFixed(5));

						//VideoSync.SynchronizeTimeDelta(-2);
						let t = (Activity.GetClosestActivityTime("Say") - _demo.ActivityTimeOffset) / _demo.ActivityTimeScale - 2;
						VideoSync.SynchronizeTime(t);
					});

					$("#yt_sync_container").append(gDbg);
				}

				function YTE_OnReady(syncVideo, event) {
					syncVideo.YouTubeLoadReady = true;

					//syncVideo.Player.setPlaybackRate(0.1);

					// Check if all videos are ready.
					for (let i in _syncVideoList) {
						if (!_syncVideoList[i].YouTubeLoadReady) return;
					}

					// Get video length to start UI.
					let duration = Infinity;
					for (let i in _syncVideoList) {
						let sv = _syncVideoList[i];
						duration = Math.min(sv.Player.getDuration() - sv.VideoInfo.ZeroTime - _demo.ActivityTimeOffset, duration);
					}
					_syncVideosDuration = duration;
					UI.BuildControls();

					// Starts activities.
					Activity.Start();

					// Starts video.
					YTP_Synchronize(0.0);
				}

				function YTE_OnStateChange(syncVideo, event) {
					let s0 = VideoSync.GlobalPlayState;

					UpdateGlobalPlayState();

					/*
					let color = "transparent";
					switch (event.data) {
						case YT.PlayerState.UNSTARTED:
							color = "#37474F"; // unstarted = gray
							break;
						case YT.PlayerState.ENDED:
							color = "#FFFF00"; // ended = yellow
							break;
						case YT.PlayerState.PLAYING:
							color = "#33691E"; // playing = green
							break;
						case YT.PlayerState.PAUSED:
							color = "#DD2C00"; // paused = red
							break;
						case YT.PlayerState.BUFFERING:
							color = "#AA00FF"; // buffering = purple
							break;
						case YT.PlayerState.CUED: // Ready to play, but not buffered.
							color = "#FF6DOO"; // video cued = orange
							break;
					}

					$("#" + syncVideo.IFrameID)
						.css("border-color", color)
						.css("border-width", 4);
					*/

					let s1 = VideoSync.GlobalPlayState;
					if (s0 != s1) {
						UI.StateChanged(s1);
						Music.StateChanged(s1);
					}

				}

				function YTE_OnPlaybackQualityChange(syncVideo, event) {

				}

				function YTE_OnPlaybackRateChange(syncVideo, event) {

				}

				function YTE_OnError(syncVideo, event) {

				}

				function Seek(syncVideo, time, debug) {
					let s = syncVideo.Seek,
						p = syncVideo.Player;
					s.Time = time + syncVideo.VideoInfo.ZeroTime + _demo.ActivityTimeOffset; // Actual video time.
					if (!s.Seeking) {
						s.Seeking = true;
						s.Debug = typeof(debug) === "boolean" ? debug : false;
						s.Mute = p.isMuted();
					}
					p.mute();
					p.playVideo();
					p.seekTo(s.Time);
				}

				var _playIntervalID;

				function YTP_Play() {
					for (let i in _syncVideoList) {
						let p = _syncVideoList[i].Player;
						p.playVideo();
					}

					clearInterval(_playIntervalID);
					_playIntervalID = setInterval(function() {
						// Play by brute force.

						let allPlaying = true;
						for (let i in _syncVideoList) {
							let p = _syncVideoList[i].Player;
							if (p.getPlayerState() != YT.PlayerState.PLAYING) {
								p.playVideo();
								allPlaying = false;
							}
						}
						if (allPlaying) {
							clearInterval(_playIntervalID);
						}
					}, 100);
				}

				this.Play = function() {
					YTP_Play();
				}

				function YTP_Pause() {
					for (let i in _syncVideoList) {
						_syncVideoList[i].Player.pauseVideo();
					}
				}

				this.Pause = function() {
					YTP_Pause();
				}

				function YTP_Synchronize(time) {
					let t = Math.max(Math.min(time, VideoSync.GetSyncVideosDuration()), 0);
					_syncTime = t;
					UI.UpdateSeekBar(t);
					Activity.Seek(t);
				}
				
				this.SynchronizeTime = function(time) {
					YTP_Synchronize(time);
				}

				this.SynchronizeTimeDelta = function(dt) {
					let t = isFinite(_syncTime) ? _syncTime : VideoSync.GetSyncVideosCurrentTime();
					YTP_Synchronize(Math.max(Math.min(t + dt, VideoSync.GetSyncVideosDuration()), 0));
				}
			}

			var UI = new function() {
				var _resizeTimeoutID;
				var _refreshControlsIntervalID;
				var _uiLayoutStyle;
				var _controlJq;

				let enumValue = 0;

				// UILS = UI layout style
				const UILS_Tile = enumValue++;
				const UILS_MainAndThumbnails = enumValue++;

				this.Start = function() {
					// Adds control bar.

					// Do not always resize to save performance.
					$(window).resize(function() {
						clearTimeout(_resizeTimeoutID);
						_resizeTimeoutID = setTimeout(function() {
							RefreshBoxes();
							_resizeTimeoutID = 0;
						}, 100);
					});

					_controlJq = _containerJq.find(".control");

					// Bind click events.
					_controlJq.find(".bar")
						.click(function(e) { ProgressBarClick($(this), e); })
						.mousemove(function(e) { ProgressBarHover($(this), e, true); })
						.hover(
							function(e) { ProgressBarHover($(this), e, true); },
							function(e) { ProgressBarHover($(this), e, false); } );
					_controlJq.find(".play").click(function(e) { PlayBtnClick($(this), e) });
					_controlJq.find(".full-screen").click(function(e) { ToggleFullScreen(_userContainerJq[0]); });
					_controlJq.find(".tile-layout").click(function(e) { SetLayoutStyle(UILS_MainAndThumbnails) });
					_controlJq.find(".parent-child-layout").click(function(e) { SetLayoutStyle(UILS_Tile) });

					clearInterval(_refreshControlsIntervalID);
					_refreshControlsIntervalID = setInterval(RefreshControlsLoop, 100);

					// Initialize all variables.
					_map = undefined;

					// Initialize music and sound.
					Music.Initialize();
					Sound.Initialize();

					// Set default style.
					_uiLayoutStyle = UILS_Tile;
					InitializeBoxes();
					ResetBoxIndices();
					RefreshBoxes();

					// Make controls more convenient.
					$(document).keydown(function(event) {
						let key = event.key;
						if (key.length === 1) key = key.toLowerCase();

						switch (key) {
							case "l": NextLayoutStyle(); break;
							case "r": break;
							case "ArrowLeft": VideoSync.SynchronizeTimeDelta(-5); break;
							case "ArrowUp": VideoSync.SynchronizeTimeDelta(-10); break;
							case "ArrowRight": VideoSync.SynchronizeTimeDelta(5); break;
							case "ArrowDown": VideoSync.SynchronizeTimeDelta(10); break;
						}
					});
				}

				this.Close = function() {
					// Flushes UI container.
					if (_userContainerJq) {
						_userContainerJq.empty();
						_userContainerJq = undefined;
					}

					clearInterval(_resizeTimeoutID);
					clearInterval(_refreshControlsIntervalID);
				}

				// Builds controls for this video player.
				this.BuildControls = function() {
					let duration = VideoSync.GetSyncVideosDuration();
				}

				function InitializeBoxes() {
					_containerJq.find(".yt_sync_box").each(function() {
						function _TriggerDOM(jqe) {
							return jqe.originalEvent.target;
						}
						function _GetCoverJQ(jqe) {
							return $(_TriggerDOM(jqe)).find(".box_cover");
						}
						function _SetDataBoxIndex(jqe) {
							let e = jqe.originalEvent;
							e.dataTransfer.setData("text/plain", GetBoxIndex(e.target).toString());
						}
						function _GetDataBoxIndex(jqe) {
							return parseInt(jqe.originalEvent.dataTransfer.getData("text/plain"));
						}

						let t = $(this);
						t.attr("draggable", "true")
							// Events fired on the draggable target (the source element)
							.on("dragstart", function(jqe) {
								//jqe.originalEvent.preventDefault();
								_SetDataBoxIndex(jqe);
								_GetCoverJQ(jqe).addClass("drag_src");
							})
							.on("drag", function(jqe) {
								//jqe.originalEvent.preventDefault();
							})
							.on("dragend", function(jqe) {
								_GetCoverJQ(jqe).removeClass("drag_src");
							})
							// Events fired on the drop target
							.on("dragenter", function(jqe) {
								jqe.originalEvent.preventDefault();
								let c = _GetCoverJQ(jqe);
								if (c.hasClass("drag_src")) return;
								c.addClass("drag_dst");
							})
							.on("dragover", function(jqe) {
								jqe.originalEvent.preventDefault();
							})
							.on("dragleave", function(jqe) {
								_GetCoverJQ(jqe).removeClass("drag_dst");
							})
							.on("drop", function(jqe) {
								jqe.stopPropagation();
								jqe.preventDefault();

								let c = _GetCoverJQ(jqe);
								c.removeClass("drag_dst");
								if (c.hasClass("drag_src")) return;
								SwapBoxes(_GetDataBoxIndex(jqe), GetBoxIndex(_TriggerDOM(jqe)));
							});
					});

					ResetBoxIndices();
				}

				function ResetBoxIndices() {
					let i = 0;
					_containerJq.find(".yt_sync_box").each(function() {
						SetBoxIndex(this, i++);
					});
				}

				function GetBoxIndex(boxDOM) {
					return $(boxDOM).data("box-index");
				}
				this.GetBoxIndex = GetBoxIndex;

				this.GetPrimaryBox = function() {
					let dom;
					_containerJq.find(".yt_sync_box").each(function() {
						if (GetBoxIndex(this) === 0) {
							dom = this;
						}
					});
					return dom;
				}

				function SetBoxIndex(boxDOM, i) {
					$(boxDOM).data("box-index", i);
				}

				function GetBoxesDOM() {
					let boxes = [];
					_containerJq.find(".yt_sync_box").each(function() {
						boxes[GetBoxIndex(this)] = this;
					});
					return boxes;
				}

				function RefreshBoxes() {
					let containerW = _containerJq.width(),
						containerH = _containerJq.height();
					let aspectRatio = 4 / 3; // Currently all videos are with this aspect ratio, so we calculate it once here.
					let boxes = GetBoxesDOM();
					let refreshPosAndSize = function(jq, maxWidth, maxHeight, ar, x0, y0) {
						let arBox = maxWidth / maxHeight;
						let w, h;
						if (arBox >= ar) {
							w = maxWidth;
							h = w / ar;
						}
						else {
							h = maxHeight;
							w = h * ar;
						}
						let x = x0 + (maxWidth - w) * 0.5,
							y = y0 + (maxHeight - h) * 0.5;
						jq.css("width", w.toFixed(3) + "px")
							.css("height", h.toFixed(3) + "px")
							.css("left", x.toFixed(3) + "px")
							.css("top", y.toFixed(3) + "px");
					}
					switch (_uiLayoutStyle) {
						case UILS_Tile: {
								let boxCount = boxes.length;
								let cAR = containerW / containerH; // Container's aspect ratio.

								// Find a combination with least empty space.
								let bestEmptyArea = Infinity;
								let bestRowCount, bestColCount, bestBlockW, bestBlockH;
								for (let i = 1; i <= boxCount; i++) {
									let row = Math.ceil(boxCount / i); // Number of rows required.
									let rcAR = aspectRatio * i / row;
									let blockW, blockH;
									if (rcAR > cAR) {
										blockW = containerW / i;
										blockH = blockW / aspectRatio;
									}
									else {
										blockH = containerH / row;
										blockW = blockH * aspectRatio;
									}
									let emptyArea = containerW * containerH - blockW * blockH * boxCount;
									if (emptyArea < bestEmptyArea) {
										bestEmptyArea = emptyArea;
										bestRowCount = row;
										bestColCount = i;
										bestBlockW = blockW;
										bestBlockH = blockH;
									}
								}

								let x0 = (containerW - (bestColCount * bestBlockW)) * 0.5,
									x = x0,
									y = (containerH - (bestRowCount * bestBlockH)) * 0.5;
								let r = 0; c = 0;
								for (let i = 0; i < boxCount; i++) {
									refreshPosAndSize($(boxes[i]), bestBlockW, bestBlockH, aspectRatio, x, y);
									if (++c >= bestColCount) {
										c = 0;
										x = x0;
										r++;
										y += bestBlockH;
									}
									else {
										x += bestBlockW;
									}
								}
							}
							break;
						case UILS_MainAndThumbnails: {
								// The first box is main and the rest of them will be thumbnails.

								const MinThumbnailScale = 0.2; // Min thubmnail is 0.2 of width and height to the size of main video.

								// Determine gap between thumbnails.
								let tnGap = Math.min(containerW, containerH, 1024) / 1024 * 16; // Max 16 pixels between thumbnails.

								let boxCount = boxes.length;
								let tnCount = boxCount - 1;
								let cAR = containerW / containerH; // Container's aspect ratio.
								let tnRight = cAR >= aspectRatio; // Thumbnail at the right side.
								if (tnRight) {
									const MaxRowCount = 4;

									// Maximum possible size for main video.
									let mainH = containerH,
										mainW = mainH * aspectRatio;

									// Minimum possible columns.
									let minColCount = Math.ceil(tnCount / MaxRowCount);

									// Minimum allowable size for thumbnails.
									let tnMinH = (containerH - (MaxRowCount - 1) * tnGap) / MaxRowCount,
										tnMinW = tnMinH * aspectRatio;

									// Minimum required width to contain all thumbnails.
									let tnContMinW = minColCount * (tnMinW + tnGap);

									let tnW, tnRow;
									if (containerW >= mainW + tnContMinW) {
										// Tries to find a biggest thumbnail size.
										let avW = containerW - mainW,
											avH = containerH;
										tnW = -Infinity;
										tnRow = MaxRowCount;
										for (let r = Math.min(MaxRowCount, tnCount); r >= 1; r--) {
											let c = Math.ceil(tnCount / r);
											let tnTestW1 = (avW - c * tnGap) / c, // Max width with respect to available width.
												tnTestW2 = ((avH - (r - 1) * tnGap) / r) * aspectRatio, // Max width with respect to available height.
												tnTestW = Math.min(tnTestW1, tnTestW2);
											if (tnTestW >= tnMinW && tnTestW >= tnW) { // This combination is possible.
												tnW = tnTestW;
												tnRow = r;
											}
										}
									}
									else {
										// We need to use min thumbnail size and shrink main video.
										mainW = containerW - tnContMinW;
										mainH = mainW / aspectRatio;
										tnW = tnMinW;
										tnRow = Math.min(MaxRowCount, tnCount);
									}

									let tnCol = Math.ceil(tnCount / tnRow),
										tnH = tnW / aspectRatio;

/*
									console.log("tnRow x tnCol = " + tnRow + " x " + tnCol);
									console.log("tnW x tnH = " + tnW + " x " + tnH);
*/

									// Arranges main video.
									let x = (containerW - (mainW + (tnGap + tnW) * tnCol)) * 0.5,
										y = (containerH - mainH) * 0.5;
									refreshPosAndSize($(boxes[0]), mainW, mainH, aspectRatio, x, y);

									// Arranges thumbnail videos.
									let x0 = x + mainW + tnGap;
									x = x0;
									y = (containerH - (tnH * tnRow + (tnRow - 1) * tnGap)) * 0.5;
									let c = 0;
									for (let i = 1; i <= tnCount; i++) {
										refreshPosAndSize($(boxes[i]), tnW, tnH, aspectRatio, x, y);
										c++;
										if (c >= tnCol) {
											x = x0;
											y += tnGap + tnH;
											c = 0;
										}
										else {
											x += tnGap + tnW;
										}
									}
								}
								else {
									const MaxColCount = 4;

									// Maximum possible size for main video.
									let mainW = containerW,
										mainH = mainW / aspectRatio;

									// Minimum possible rows.
									let minRowCount = Math.ceil(tnCount / MaxColCount);

									// Minimum allowable size for thumbnails.
									let tnMinW = (containerW - (MaxColCount - 1) * tnGap) / MaxColCount,
										tnMinH = tnMinW / aspectRatio;

									// Minimum required height to contain all thumbnails.
									let tnContMinH = minRowCount * (tnMinH + tnGap);

									let tnH, tnCol;
									if (containerH >= mainH + tnContMinH) {
										// Tries to find a biggest thumbnail size.
										let avH = containerH - mainH,
											avW = containerW;
										tnH = -Infinity;
										tnCol = MaxColCount;
										for (let c = Math.min(MaxColCount, tnCount); c >= 1; c--) {
											let r = Math.ceil(tnCount / c);
											let tnTestH1 = (avH - r * tnGap) / r, // Max height with respect to available width.
												tnTestH2 = ((avW - (c - 1) * tnGap) / c) / aspectRatio, // Max height with respect to available width.
												tnTestH = Math.min(tnTestH1, tnTestH2);
											if (tnTestH >= tnMinH && tnTestH >= tnH) { // This combination is possible.
												tnH = tnTestH;
												tnCol = c;
											}
										}
									}
									else {
										// We need to use min thumbnail size and shrink main video.
										mainH = containerH - tnContMinH;
										mainW = mainH * aspectRatio;
										tnH = tnMinH;
										tnCol = Math.min(MaxColCount, tnCount);
									}

									let tnRow = Math.ceil(tnCount / tnCol),
										tnW = tnH * aspectRatio;

									// Arranges main video.
									let x = (containerW - mainW) * 0.5,
										y = (containerH - (mainH + (tnGap + tnH) * tnRow)) * 0.5;
									refreshPosAndSize($(boxes[0]), mainW, mainH, aspectRatio, x, y);

									// Arranges thumbnail videos.
									let x0 = (containerW - (tnW * tnCol + (tnCol - 1) * tnGap)) * 0.5;
									x = x0;
									y += mainH + tnGap;
									let c = 0;
									for (let i = 1; i <= tnCount; i++) {
										refreshPosAndSize($(boxes[i]), tnW, tnH, aspectRatio, x, y);
										c++;
										if (c >= tnCol) {
											x = x0;
											y += tnGap + tnH;
											c = 0;
										}
										else {
											x += tnGap + tnW;
										}
									}
								}
							}
							break;
						default:
							console.log("Undefined UI layout style: " + _uiLayoutStyle);
							break;
					}
					// Keep aspect ratio to fit parent.

					_controlJq.find(".tile-layout")
						.css("display", _uiLayoutStyle == UILS_Tile ? "inline-block" : "none");
					_controlJq.find(".parent-child-layout")
						.css("display", _uiLayoutStyle == UILS_MainAndThumbnails ? "inline-block" : "none");
				}

				function NextLayoutStyle() {
					if (_uiLayoutStyle == UILS_MainAndThumbnails) {
						_uiLayoutStyle = UILS_Tile;
					}
					else {
						_uiLayoutStyle++;
					}

					RefreshBoxes();
				}

				function SetLayoutStyle(style) {
					if (style < 0 && style >= UILS_MainAndThumbnails) return;

					_uiLayoutStyle = style;
					RefreshBoxes();
				}

				function SwapBoxes(box0, box1) {
					function _GetBoxIndex(b) {
						if (typeof(b) === "object") b = GetBoxIndex(b);
						return typeof(b) === "number" ? b : 0;
					}

					let bn0 = _GetBoxIndex(box0),
						bn1 = _GetBoxIndex(box1);
					if (bn0 === bn1 || bn0 < 0 || bn1 < 0) return;
					let boxes = GetBoxesDOM();
					if (bn0 >= boxes.length || bn1 >= boxes.length) return;
					SetBoxIndex(boxes[bn0], bn1);
					SetBoxIndex(boxes[bn1], bn0);
					RefreshBoxes();
				}

				function RefreshControlsLoop() {
					let duration = VideoSync.GetSyncVideosDuration(),
						time = VideoSync.GetSyncVideosCurrentTime();

					if (!isFinite(duration) || !isFinite(time)) return;

					let k = (time / duration * 100).toFixed(2) + "%";
					_controlJq.find(".elapsed").css("width", k);
					_controlJq.find(".pointer").css("left", k);

					let tcDuration = GetTimeComponents(duration),
						tcTime = GetTimeComponents(time);
					$("#time-display").html(FormatTimeComponents(tcTime) + " / " + FormatTimeComponents(tcDuration));
				}

				function ProgressBarClick(jq, e) {
					/*
					let o = jq.offset();
					let x = e.pageX - o.left,
						y = e.pageY - o.top;
					*/
					let k = (e.pageX - jq.offset().left) / jq.width();
					VideoSync.SynchronizeTime(VideoSync.GetSyncVideosDuration() * k);
				}

				function ProgressBarHover(jq, e, show) {
					// Get text based on the position we are selecting.
					let k = (e.pageX - jq.offset().left) / jq.width();
					let duration = VideoSync.GetSyncVideosDuration();
					let text = show && isFinite(duration)
						? FormatTimeComponents(GetTimeComponents(duration * k))
						: "";

					// Invalid state.
					let btJq = $(".bar-time");
					if (text === "") {
						btJq.removeClass("show");
						return;
					}

					btJq.css("left", (k * 100.0).toFixed(2) + "%")
						.html(text)
						.addClass("show");
				}

				this.UpdateSeekBar = function(time) {
					let k = (isFinite(time) ? (time / VideoSync.GetSyncVideosDuration()) : 0);
					let after = time >= VideoSync.GetSyncVideosCurrentTime();
					_controlJq.find(".seek-after").css("width", ((after ? k : 0) * 100).toFixed(2) + "%");
					_controlJq.find(".seek-before").css("width", ((!after ? k : 0) * 100).toFixed(2) + "%");
				}

				function PlayBtnClick(iq, e) {
					switch (VideoSync.GlobalPlayState) {
						case YT.PlayerState.PLAYING:
							VideoSync.Pause();
							break;
						default:
						case YT.PlayerState.PAUSED:
							VideoSync.Play();
							break;
						case YT.PlayerState.ENDED:
							VideoSync.SynchronizeTime(0);
							VideoSync.Play();
							break;
					}
				}

				function GetTimeComponents(time) {
					return time > 0
					? {
						Hour:  Math.floor(time / 3600),
						Minute: Math.floor((time % 3600) / 60),
						Second: Math.floor(time % 60)
					}
					: {
						Hour: 0,
						Minute: 0,
						Second: 0
					};
				}

				function FormatTimeComponents(tc) {
					return (tc.Hour > 0 ? (h.toString() + ":") : "")
						+ ("0" + tc.Minute.toString()).substr(-2)
						+ ":" +("0" + tc.Second.toString()).substr(-2);
				}

				var _playBtnClassList;

				function StateChanged(state) {
					let list = _playBtnClassList;
					if (typeof(list) !== "object") {
						list = {};
						list[YT.PlayerState.UNSTARTED] = "fa-play";
						list[YT.PlayerState.ENDED] = "fa-redo";
						list[YT.PlayerState.PLAYING] = "fa-pause";
						list[YT.PlayerState.PAUSED] = "fa-play";
						list[YT.PlayerState.BUFFERING] = "fa-cloud-download-alt";
						_playBtnClassList = list;
					}

					let targetClass = list[VideoSync.GlobalPlayState];
					if (!targetClass) targetClass = "fa-stop";

					let btnJq = $(".play i");
					function updateButton(btnClass) {
						if (btnClass === targetClass) {
							btnJq.addClass(btnClass);
						}
						else {
							btnJq.removeClass(btnClass);
						}
					}

					for (let k in list) {
						updateButton(list[k]);
					}
				}
				this.StateChanged = StateChanged;

				function ToggleFullScreen(element) {
					if (!document.fullscreenElement &&	// alternative standard method
						!document.mozFullScreenElement && !document.webkitFullscreenElement) {  // current working methods
						if (element.requestFullscreen) {
							element.requestFullscreen();
						} else if (element.mozRequestFullScreen) {
							element.mozRequestFullScreen();
						} else if (element.webkitRequestFullscreen) {
							element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
						}
						
						$(".full-screen i")
							.removeClass("fa-expand-arrows-alt")
							.addClass("fa-compress-arrows-alt");
					} else {
						if (document.cancelFullScreen) {
							document.cancelFullScreen();
						} else if (document.mozCancelFullScreen) {
							document.mozCancelFullScreen();
						} else if (document.webkitCancelFullScreen) {
							document.webkitCancelFullScreen();
						}

						$(".full-screen i")
							.removeClass("fa-compress-arrows-alt")
							.addClass("fa-expand-arrows-alt");
					}
				}

				this.AddLine = function(msgClass, htmlContent, fadeTime, stayTime) {
					let jq = $("<li class='" + msgClass + "'>" + htmlContent + "</li>");
					_containerJq.find(".msg-box").append(jq);
					setTimeout(function() {
						UI.FinishLine(jq, fadeTime);
					}, stayTime);
				}

				this.GetMessageByClass = function(msgClass) {
					return _containerJq.find(".msg-box ." + msgClass);
				}

				this.FinishLine = function(jq, fadeTime) {
					jq.finish().animate({
						"height": "0",
						"opacity": "0"
					}, fadeTime, "swing", function() {
						jq.remove();
					});
				}
			}

			var Music = new function() {
				var _initialized = false;

				var _musicIsReady = false;
				var _musicPlayRetryID = 0;
				var _stopTimer_ms = 0;

				var _volume = 1.0;
				var _volumeFactor = 1.0;

				function GetBtnJq() {
					return $(".music.btn i");
				}

				function GetAudioJq() {
					return $(".music.btn audio");
				}

				function Initialize() {
					let btn = GetBtnJq();
					btn[0].muted = false;
					btn.click(Toggle);

					RefreshBtn();

					let playAudio = function () {
						let audioDOM = GetAudioJq()[0];
						let promise = audioDOM.play();

						var result = promise.then(
							function(v) { // Fulfilled.
								_musicIsReady = true;
								StopPlayRetry();
								return v; 
							},
							function(e) { // Rejected.
								_musicPlayRetryID = setTimeout(playAudio, 250); // Keep trying.
							}
						);
					};

					GetAudioJq().bind("canplay", playAudio);

					_initialized = true;
				}
				this.Initialize = Initialize;

				this.ScanLoop = function() {
					if (!_initialized) return;
					CheckMusic();
					CheckVolume();
				}

				function CheckMusic() {
					if (VideoSync.IsPlaying()) {
						_stopTimer_ms = 0;
					}
					else {
						_stopTimer_ms += 100; // Adds 100 ms.
					}

					let vf = 1.0 - (_stopTimer_ms - 10000) / 20000;
					vf = vf > 1.0 ? 1.0 : (vf < 0 ? 0 : vf);

					// We can pause music since there's no volume.
					if (vf <= 0) Music.Pause();

					_volumeFactor = vf;
				}

				function CheckVolume() {
					GetAudioJq()[0].volume = _volume * _volumeFactor;
				}

				function StopPlayRetry() {
					clearTimeout(_musicPlayRetryID);
					_musicPlayRetryID = 0;
				}

				function Toggle() {
					let audio = GetAudioJq()[0];
					audio.muted = !audio.muted;
					RefreshBtn();
				}

				function GetMusicPath(wad, name) {
					let w = GameInfo.WadInfo[wad];
					if (!w) return;
					let d = w.Data[name.toUpperCase()]; // Search by name directly.
					if (!d) { // If it is not name, use "Music" tag instead.
						for (let k in w.Data) {
							let wdm = w.Data[k].Music;
							if (typeof (wdm) === "string" && wdm.startsWith(name)) {
								d = w.Data[k];
								break;
							}
						}
					}
					if (!d) return;
					let m = d.Music;
					if (typeof (m) !== "string") return;

					let tokens = m.split("|");
					switch (tokens.length) {
						case 1: return "https://doombarracks.github.io/DoomMusic/" + wad + "/" + tokens[0];
						case 2: return GetMusicPath(tokens[0], tokens[1]);
					}
					return undefined;
				}

				function SetMusicByMap(wad, name) {
					SetMusic(GetMusicPath(wad, name));
				}
				this.SetMusicByMap = SetMusicByMap;

				function SetMusic(path) {
					if (typeof (path) !== "string") return;

					// Find music type.
					let i = path.lastIndexOf(".");
					if (i <= 0) return undefined;
					let ext = path.substr((i + 1) - path.length);
					let type;
					switch (ext.toLowerCase()) {
						case "opus": type = "audio/ogg; codecs=opus"; break;
						case "mp3": type = "audio/mpeg"; break;
						default: return;
					}

					let audio = GetAudioJq();
					let source = audio.find("source");

					// Do not load twice.
					if (source[0].src === path) return;

					source[0].src = path;
					source[0].type = type;

					StopPlayRetry();
					audio[0].load();
					_musicIsReady = false;
				}
				this.SetMusic = SetMusic;

				function Pause() {
					if (!_musicIsReady) return;
					GetAudioJq()[0].pause();
				}
				this.Pause = Pause;

				function Unpause() {
					if (!_musicIsReady) return;
					GetAudioJq()[0].play();
				}
				this.Unpause = Unpause;

				function StateChanged(state) {
					switch (state) {
						case YT.PlayerState.UNSTARTED: break;
						case YT.PlayerState.BUFFERING: break;
						case YT.PlayerState.CUED: break;
						case YT.PlayerState.PLAYING: Unpause(); break;
						case YT.PlayerState.PAUSED: break;
						case YT.PlayerState.ENDED: break;
					}
				}
				this.StateChanged = StateChanged;

				function RefreshBtn() {
					let btn = GetBtnJq();
					let mute = GetAudioJq()[0].muted;

					if (mute) {
						btn.addClass("mute");
					}
					else {
						btn.removeClass("mute");
					}
				}
			}

			var Sound = new function () {
				var _mute = false;
				var _force = false;
				var _volume = 100;

				function GetBtnJq() {
					return $(".sound.btn i");
				}

				this.ScanLoop = function() {
					CheckSound();
				}

				function CheckSound() {
					let mute = _force || _mute;
					let volume = _volume;
					ForEachYoutubePlayerDOM(function (p) {
						if (typeof(p.isMuted) === "function" && p.isMuted() != mute) {
							if (mute) p.mute();
							else p.unMute();
						}
						if (typeof(p.getVolume) === "function" && p.getVolume() != volume) {
							p.setVolume(volume);
						}
					});
				}

				this.ForceMute = function(force) {
					_force = force;
				}

				function GetYoutubePlayerDOMs() {
					let players = [];
					for (let i in _syncVideoList) {
						players.push(_syncVideoList[i].Player);
					}
					return players;
				}

				function ForEachYoutubePlayerDOM(f) {
					let players = GetYoutubePlayerDOMs();
					for (let i in players) {
						f(players[i]);
					}
				}

				function Initialize() {
					let btn = GetBtnJq();
					btn.click(Toggle);
					RefreshBtn();
				}
				this.Initialize = Initialize;

				function IsMuted() {
					return _mute;
					/*
					let mute = false;
					ForEachYoutubePlayerDOM(function (p) {
						if (typeof (p.isMuted) === "function") {
							mute |= p.isMuted();
						}
					});
					return mute;
					*/
				}

				function Mute(mute) {
					if (mute) {
						ForEachYoutubePlayerDOM(function (p) {
							if (typeof(p.mute) === "function") p.mute();
						});
					}
					else {
						ForEachYoutubePlayerDOM(function (p) {
							if (typeof(p.unMute) === "function") p.unMute();
						});
					}
				}
				this.Mute = Mute;

				function Toggle() {
					Mute(!_mute)
					_mute = !_mute;
					RefreshBtn();
				}

				function RefreshBtn() {
					let btnJq = GetBtnJq();
					if (IsMuted()) {
						btnJq.addClass("mute");
					}
					else {
						btnJq.removeClass("mute");
					}
				}
			}

			var Activity = new function() {
				var _initialized = false;

				var _activityTime;

				// For performance.
				var _optimizedActivities; // For better performance.
				var _seekActivities; // For better performance during seeking.

				// For tracing data within the whole demo.
				var _game; // Game for other references.
				var _map; // Name of the map.
				var _players; // Name of all players. Key: true player name, Value: in-game player name.

				// Out of sync message indicator.
				var _outOfSync = false;

				var _musicStopTimer = 0;

				this.Start = function() {
					BuildActivities();

					_activityTime = 0.0; // Reset last monitoring time.

					_game = _demo.Game;
					_map = undefined;
					let players = {};
					for (let i in _demo.Videos) {
						players[_demo.Videos[i].PlayerName] = undefined;
					}
					_players = players;

					_initialized = true;
				}

				this.Close = function() {
					clearInterval(_scanLoopIntervalID);
					_scanLoopIntervalID = 0;
				}

				this.ScanLoop = function() {
					if (!_initialized) return;
					CheckActivity();_initialized
				}

				function GetActivityCurrentTime() {
					return VideoSync.GetSyncVideosCurrentTime() * _demo.ActivityTimeScale + _demo.ActivityTimeOffset;
				}

				function CheckActivity() {
					if (!VideoSync.IsPlaying()) return;

					// Uses time from the first video as reference.
					let vt = GetActivityCurrentTime();

					// This loop iterate every 0.1 second, so we assume this is long enough to cut-off and consider a seek operation.
					if (vt - _activityTime < 1.0) {
						let activities = GetCrossingActivities(vt);
						if (activities.length > 0) { // We got some activities.
							ProcessActivities(activities);
						}
					}

					// All operations are done, we now update time so it can be referenced in the next iteration.
					_activityTime = vt;
				}

				this.Seek = function(time) {
					// Add offset back.
					time += _demo.ActivityTimeOffset;

					_activityTime = time;

					// New table to compare with the old one.
					let map;
					let players = {};

					for (let i in _demo.Videos) {
						let pn = _demo.Videos[i].PlayerName;
						let tpn = DemoHelper.GetTruePlayerName(pn);
						players[tpn] = {
							Operation: "Kick",
							PlayerName: typeof(_players[tpn]) !== "undefined" ? _players[tpn] : pn,
							MessageType: 5, // Our own message.
							Tic: 0
						};
					}

					for (let i in _seekActivities) {
						let a = _seekActivities[i];

						// Do not proceed since we passed time.
						if (a.Tic / 35.0 > time) {
							break;
						}

						switch (a.Operation) {
							case "Map":
								map = a.MapName;
								break;
							case "SetPlayer":
								players[a.TruePlayerName] = a;
								break;
							case "Kick":
								players[a.TruePlayerName] = a;
								break;
						}
					}

					// Updates map name.
					if (map !== _map) {
						ActOp_Map(map);
					}

					// Updates player names.
					let aSort = [];
					for (let tn in players) {
						aSort.push(players[tn]);
					}
					aSort.sort(function(x, y) { return x.Tic > y.Tic; });
					for (let i in aSort) {
						let a = aSort[i];
						if (a.Operation === "SetPlayer") {
							ActOp_SetPlayer(a.PlayerName);
						}
						else {
							ActOp_Kick(a.PlayerName, a.MessageType);
						}
					}
				}

				// Gets an array of all activities we passed in ascending order by time.
				function GetCrossingActivities(time) {
					// Time goes backwards.
					if (time < _activityTime) {
						return [];
					}

					let i0 = GetActivityIndexByTime(_activityTime),
						i1 = GetActivityIndexByTime(time);
					return i0 != i1 ? _optimizedActivities.slice(i0, i1) : [];
				}

				// Gets first activity index not yet reached by specified time.
				// If there is no activitiy left, -1 will be returned.
				function GetActivityIndexByTime(time) {
					let a = _optimizedActivities;
					let aLen = a.length;
					let tic = time * 35.0;
					
					// Checks boundaries.
					if (tic <= a[0].Tic) return 0;
					if (tic > a[aLen - 1].Tic) return aLen;

					// We can safely do binary search here.
					let lower = 0, upper = aLen - 1;
					let loopCount = 0;
					while (lower < upper && loopCount < aLen) {
						let i = (lower + upper) >> 1;
						if (i == lower && lower < upper) i++; // Prevents to stuck at the same index.
						else if (i == upper && upper > lower) i--; // Prevents to stuck at the same index.
						let t1 = a[i].Tic,
							t0 = i == 0 ? 0 : a[i - 1].Tic;
						if (tic > t1) { // Already passed.
							lower = i;
						}
						else if (tic >= t0) { // Gotcha! (tic >= t0 && tic <= t1)
							return i;
						}
						else { // Not yet. (tic < t0)
							upper = i;
						}
						loopCount++;
					}

					return 0;
				}

				function GetClosestActivityTime(operation) {
					let ct = GetActivityCurrentTime();
					let i = GetActivityIndexByTime(ct) - 1;

					while (i >= 0
						&& operation
						&& _optimizedActivities[i].Operation !== operation) {
						i--;
					}
					return i >= 0 ? _optimizedActivities[i].Tic / 35 : 0;
				}
				this.GetClosestActivityTime = GetClosestActivityTime;

				// Build activity tables for better performance.
				function BuildActivities() {
					let activities = _demo.Activity;
					let optimized = []; // Optimized activity table mainly eliminates duplicate SetPlayer operations.
					let seek = []; // Seek activity table mainly eliminates "Say" operations since they are unnecessary for seeking.
					let nameTable = {}; // For eliminating duplicate names.
					let tpn; // True player name.
					for (let i in activities) {
						let a = activities[i];

						// Generates this first to save performance.
						if (a.hasOwnProperty("PlayerName")) {
							tpn = DemoHelper.GetTruePlayerName(a.PlayerName);
							a.TruePlayerName = tpn;
						}
						else {
							tpn = undefined;
						}

						switch (a.Operation) {
							case "Say":
								optimized.push(a);
								break;
							case "Map":
								optimized.push(a);
								seek.push(a);
								break;
							case "Kick":
								nameTable[tpn] = undefined;
								optimized.push(a);
								seek.push(a);
								break;
							case "SetPlayer":
								if (nameTable[tpn] !== a.PlayerName) {
									nameTable[tpn] = a.PlayerName;
									optimized.push(a); // Adds only when name changes.
									seek.push(a);
								}
								break;
						}
					}
					_optimizedActivities = optimized;
					_seekActivities = seek;
				}

				function ActOp_Say(playerName, message) {
					UI.AddLine("say", "<span><span>" + playerName + "</span><span>" + message + "</span></span>", 300, 8000);
				}

				function ActOp_SetPlayer(playerName) {
					let tpn = DemoHelper.GetTruePlayerName(playerName);
					let pnLast = _players[tpn];
					if (pnLast !== playerName) { // Display only when name changes.
						if (typeof(pnLast) !== "undefined") { // Player changes name.
							UI.AddLine("set-player", "<span>Player <span class='name'>" + pnLast + "</span> renamed to <span class='name'>" + playerName + "</span>.</span>", 300, 10000);
						}
						else { // Player enters game.
							UI.AddLine("set-player", "<span>Player <span class='name'>" + playerName + "</span> joins the game.</span>", 300, 10000);
						}
						_players[tpn] = playerName;

						let sv = VideoSync.GetSyncVideo(tpn);
						if (typeof(sv) !== "undefined") {
							$("#" + sv.BoxID).addClass("connected");
						}
					}
				}

				function ActOp_Map(mapName) {
					if (mapName) {
						UI.FinishLine(UI.GetMessageByClass("map"), 1000);
						UI.AddLine("map", "<span>" + DemoHelper.GetMapFullName(mapName, _demo.Game, _demo.PWADs) + "</span>", 1000, 15000);
						Music.SetMusicByMap(_game, mapName);
					}
					_map = mapName;
				}

				function ActOp_Kick(playerName, msgType) {
					let tpn = DemoHelper.GetTruePlayerName(playerName);
					let p = _players[tpn];

					if (typeof(p) === "undefined" || p.Operation == "Kick") {
						return;
					}

					let msg;
					switch (msgType) {
						case 1: msg = "has been kicked. (Go away)"; break;
						case 2: msg = "has been kicked. (Consistency failure)"; break;
						case 4: msg = "left the game. (Connection timeout)"; break;
						case 3: msg = "left the game."; break;
						case 5: msg = "removed. (Video time restore)"; break; // New message by our own.
					}
					UI.AddLine("kick", "<span><span>" + playerName + "</span><span>" + msg + "</span></span>", 300, 10000);

					_players[tpn] = undefined;

					let sv = VideoSync.GetSyncVideo(tpn);
					if (typeof(sv) !== "undefined") {
						$("#" + sv.BoxID).removeClass("connected");
					}
				}

				function GetHtmlFriendlyString(str) {
					let result = "";
					for (let i = 0, len = str.length; i < len; i++) {
						let c = str.charAt(i);
						switch (c) {
							case " ": c = "&nbsp;"; break;
							case "&": c = "&amp;"; break;
							case "<": c = "&lt;"; break;
							case ">": c = "&gt;"; break;
							// Reserved.
							case "©": c = "&copy;"; break;
							case "®": c = "&reg;"; break;
							case "™": c = "&trade;"; break;
							case "é": c = "&eacute;"; break;
							case "è": c = "&egrave;"; break;
							case "ñ": c = "&ntilde;"; break;
							case "¢": c = "&cent;"; break;
						}
						result += c;
					}
					return result;
				}

				// Processes all activities.
				function ProcessActivities(activities) {
					for (let i in activities) {
						let a = activities[i];
						switch (a.Operation) {
							case "Say":
								ActOp_Say(a.PlayerName, GetHtmlFriendlyString(a.Message));
								break;
							case "SetPlayer":
								ActOp_SetPlayer(a.PlayerName);
								break;
							case "Map":
								ActOp_Map(a.MapName);
								break;
							case "Kick":
								ActOp_Kick(a.PlayerName, a.MessageType);
								break;
							default:
								console.warning("Unknown activity operation: " + a.Operation);
								break;
						}
					}
				}
			}
		}

		var GameInfo = gameInfoTable;

		var DemoHelper = new function() {
			// Gets full map name of specified map.
			this.GetMapFullName = function(name, iwad, pwads) {
				let info = GetMapInfo(name, iwad, pwads);
				return typeof(info) !== "undefined" ? (name + ": " + info.Name) : name;
			}
		
			function GetMapInfo(name, iwad, pwads) {
				// The correct way should be mergin two object and overwrite by the newer one.
				// But I think there is no such need for all our demos.

				let table = undefined;
				let wadInfo = GameInfo.WadInfo;

				name = name.toUpperCase();
				
				if (typeof(iwad) !== "string") iwad = "";
				iwad = iwad.toLowerCase().replace(".wad", "");
				switch (iwad) {
					case "doom": table = wadInfo.Doom; break;
					case "doom2": table = wadInfo.Doom2; break;
					case "tnt": table = wadInfo.TNT; break;
					case "plutonia": table = wadInfo.Plutonia; break;
					default: table = name.startsWith("MAP") ? wadInfo.Doom2 : wadInfo.Doom;
				}

				if (Array.isArray(pwads)) {
					for (let i in pwads) {
						let pwad = pwads[i].toLowerCase().replace(".wad", "");
						switch (pwad) {
							case "mm2": table = wadInfo["Memento Mori II"]; break;
							case "hr2":
							case "hr2final": table = wadInfo["Hell Revealed II"]; break;
							case "marswar":
							case "marsw301": table = wadInfo["Mars War"]; break;
							case "twzone2": table = wadInfo["The Twilight Zone 2"]; break;
							case "vilcore": table = wadInfo["The Vilecore"]; break;
							//default: console.log("Unrecognized PWAD: " + pwads[i]);
						}
					}
				}

				return table.Data[name.toUpperCase()];
			}

			// Maps in-game player name to actual player name we are familiar with.
			this.GetTruePlayerName = function(inGameName) {
				switch (inGameName.toLowerCase()) {
					case "doom nobody":
					case "doomenergy": return "DoomEnergy";
					case "rock1246": return "Rock1246";
					case "aj": return "AJ";
					case "no95": return "No95";
					case "dino": return "Dino";
					case "shon": return "Shon";
					case "mario":
					case "d.b-mario": return "Mario";
					case "unicode": return "Unicode";
					case "qqw94": return "QQW94";
					case "e.f":
					case "extremely fantasy":
					case "-=d.b=- e.f.":
					case "=d.b= e.f":
					case "=d.b=e.f": return "EF";
					case "orcs":
					case "kevin": return "Orcs";
					case "904631": return "904631";
					case "jackgo0932": return "Jackgo0932";
					case "timothy":
					case "=tcl=": return "Timothy";
					case "guy": return "Guy";
					case "mdt":
					case "m.d.t":
					case "doom.mike":
					case "= mike =":
					case "super.mike.doom.team":
					case "my no is mike":
					case "my name no mike":
					case "mike len":
					case "mike":
					case "mike.boss":
					case "=db= - mike.boss":
					case "mike.doom.team": return "Mike";
					case "yoyo": return "Yoyo";
					case "ajneok": return "AJNeoK";
					case "terminator": return "Terminator";
					case "ash ketchum 2005": // Not sure.
					case "arthas": return "Arthas";
					case "howie": return "Howie";
					case "caesar": return "Caesar";
					case "mink": return "Mink";
					case "darway": return "Darway";
					case "ringo": return "Ringo";
					case "e007x": return "E007X";
					case "orz gordon sto": return "Gordon";
					case "dakki": return "Dakki";
					case "kenny": return "Kenny";
					case "tnlkm": return "Tnlkm";
					case "uac": return "UAC";
					case "pkmx": return "PkmX";
					case "lui chun kei": return "Angus";
					case "weow": return "WEOW";
					case "ghost": return "Ghost";
					case "sprite": return "Sprite";
					case "saiste": return "Saiste";
					case "superman": return "Superman";
					case "paul": return "Paul";
					case "jj.mig":
					case "rei": return "Rei";
					case "hunter": return "Hunter";
					case "link": return "Link";
					case "jack": return "Jack";
					case "hbo": return "HBO";
					case "oda":
					case "to":
					case "jeffliu":
					case "masayn":
					case "masayan": return "Masayan";
					case "ash": return "Ash";
					case "y.s.c":
					case "ysc": return "YSC";
					case "secreet":
					case "[db]starlove": return "Secreet";
					case "[dj-db]jinwoo":
					case "[dj]mr.trooper": return "JinWooKo";
					case "dr.kill": return "Dr.Kill";
					case "chromatic.hp": return "Chromatic.HP";
					case "logo": return "Logo";
					case "warrior": return "Vegetto";
					// Special names with invalid characters, so their names should be manually processed first.
					case "james bond": return "James Bond";
					case "bb": return "BB";
					// Judges or spectators in DBSDMT 2005.
					case "aloven": // Skip.
					case "repo": // Skip.
					case "dth-000": // Skip.
					case "artist-hong": // Skip.
					case "user": // Skip.
					case "administrator": break; // Skip.
				}
				return this.IsTruePlayerName(name) ? name : undefined;
			}

			// Checks whether this name is true player name.
			this.IsTruePlayerName = function(name) {
				switch (name) {
					case "904631":
					case "AJ":
					case "AJNeoK":
					case "Angus":
					case "Arthas":
					case "Ash":
					case "BB":
					case "Caesar":
					case "Chromatic.HP":
					case "Dakki":
					case "Darway":
					case "Dino":
					case "DoomEnergy":
					case "Dr.Kill":
					case "E007X":
					case "EF":
					case "Ghost":
					case "Gordon":
					case "Guy":
					case "HBO":
					case "Howie":
					case "Hunter":
					case "Jack":
					case "Jackgo0932":
					case "James Bond":
					case "JinWooKo":
					case "Kenny":
					case "Link":
					case "Logo":
					case "Mario":
					case "Masayan":
					case "Mike":
					case "Mink":
					case "No95":
					case "Orcs":
					case "Paul":
					case "PkmX":
					case "QQW94":
					case "Rei":
					case "Ringo":
					case "Rock1246":
					case "Saiste":
					case "Secreet":
					case "Shon":
					case "Sprite":
					case "Superman":
					case "Terminator":
					case "Timothy":
					case "Tnlkm":
					case "UAC":
					case "Unicode":
					case "Vegetto":
					case "WEOW":
					case "Yoyo":
					case "YSC": return true;
				}
				return false;
			}
		}
	</script>
</body>
</html>